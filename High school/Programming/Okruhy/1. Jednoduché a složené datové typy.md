---
tags:
  - high-school
  - graduation
source:
  - http://web.archive.org/web/20250126223336/https://wiki.gml.cz/doku.php/informatika:maturita:20a
---
- [x] Jednoduché a složené datové typy ✅ 2025-01-27

> Datový typ definuje v programování druh nebo význam hodnot, kterých smí nabývat proměnná (nebo konstanta). Datový typ je určen oborem hodnot a zároveň výpočetními operacemi, které lze s hodnotami tohoto typu provádět.
> <cite>-- GML wiki, Datové typy strukturovaných jazyků</cite>

Konkrétní implementace datových typů se liší od jazyka k jazyku. Zpravidla však můžeme ve většině jazycích nalézt podobné typy, které implementují podobné operace.
# Jednoduché typy
- většinou přímo definované jazykem
- dělíme je na ordinální a neordinální
- v některých jazycích lze rozlišit mezi *signed* ("označené") a *unsigned* ("neoznačené") hodnotami
	- signed využívají poslední, *least significant* bit pro znaménko, kde 0 zpravidla udává kladné hodnoty a 1 záporné
	- proto také dochází k menšímu oboru hodnot
	- unsigned tuto funkci nezavádí, mohou tedy obsahovat pouze kladné hodnoty
## Ordinální
- tvoří lineárně uspořádanou množinu, kde u každého prvku lze nalézt **předchůdce** i **následovníka**
### Boolean
- nejjednodušší datový typ
- reprezentován jediným bitem - 0 (false) nebo 1 (true)
- většinou však pro jeho uložení používáme celý byte kvůli omezením jazyků
### Integer
- celočíselný datový typ
- většinou bývá omezen na přesně definovaný počet bytů
	- v jazyce C - *int* => 4 byty, short => 2 byty
	- v Javascriptu definujeme pouze typ *number*, jehož velikost si určuje sám compiler
### Char
- datový typ odpovídající "jednomu" znaku v psané formě přirozeného jazyka
	- Zde bychom mohli povídat hodiny a hodiny o tom, jak je ve skutečnosti těžké definovat, co znamená jeden znak. Standard ASCII obsahuje 128 znaků, pro reprezentaci jednoho jeho znaku tedy potřebujeme necelý byte. V moderních systémech se však běžně používá UTF-8 pro podporu všech světových jazyků. Ten sice jako jednu jednotku používá byte, avšak jeden znak může být reprezentován libovolným počtem bytů.
	- Tady se hodně liší i implementace tohoto typu v jednotlivých jazycích. Zatímco v C se většinou jedná o jeden byte (používá se tedy někdy namísto byte typu, jeho délka je však nastavitelná), v C# se jedná o dva byty. Rust je přímo definuje jako jednu skalární Unicode hodnotu.
- většinou se označuje jednoduchými uvozovkami
## Neordinální
- netvoří lineárně uspořádanou množinu
### Float
- reálné číslo obsahující plovoucí desetinnou čárku
- několik používaných standardů
-  nejčastěji používán standard IEEE 754, který float definuje jako:
$$\pm 1 + \text{mantissa} * 2^{\text{exponent - 127}}$$
- jednotlivé části:
	- sign je poslední bit a udává znaménko
	- mantissa udává číslo za desetinnou čárkou
	- od exponentu je odečtena 127, jelikož jsou potřeba kladné i záporné exponenty (8 bitů dává maximální hodnotu 255)
- ne všechny čísla lze v tomto formátu zapsat => vznikají chyby ve výpočtech (0.1 + 0.2 = 0.333...)
- stejný standard dále zavádí typy NaN (not a number), nekonečno a rozlišuje mezi kladnou a zápornou nulou (+0 == -0)
## Nulové
- často se zavádí tzv. nulové typy, reprezentující **žádnou** hodnotu
- každý jazyk s nimi zachází trochu jinak
### Csharp
- zavádí *void* pro deklaraci funkce, která nevrací žádnou hodnotu
- zavádí tzv. nulovatelné typy (např.: nulovatelný int), které mohou nabývat jak *null*, tak jejich originální hodnotu - je tedy před každým jejich použitím nutno zkontrolovat, zda pracujeme s nějakou hodnotou, a ne s null
# Složené typy
- obsahují jeden nebo více prvků
- rozlišujeme homogenní (pole, množina) a heterogenní
- opět můžeme rozlišit i ordinální a neordinální typy (struktury, které zachovávají pořadí jednotlivých prvků)
- často jsou obsažené ve standardních knihovnách
### Pole
- anglicky *array*
- homogenní, ordinální seznam prvků
- jednotlivé prvky jsou dostupné pod číslem, tzv. *indexem* => říkáme, že tento typ je "indexovatelný" (*indexable*)
	- pokud definujeme například $a = [0, 4, 1]$, pak $a[2] = 1$
	- tuto vlastnost může implementovat kterýkoliv typ, většinou se však jedná pouze o pole
- indexování zpravidla začíná nulou
- výhodou tohoto typu je tedy možnost okamžitého přístupu ke kterékoliv položce
	- musíme znát pouze index, který můžeme jednoduše vytvořit
- prvky jsou v paměti uložené za sebou
	- lze tedy jednoduše přidat prvek na konec seznamu
	- doprostřed nebo na začátek je to těžší, musíme posunout celý seznam v paměti (např.: pokud máme pole čísel - 4 byty - velikosti 100, musíme posunout $100*4 = 400 \text{ bytů}$), což může být pro velká pole velice náročné
### List
- anglicky *list*, přesněji *linked list*
- homogenní, neordinální seznam prvků
- na rozdíl od pole ho nelze adresovat pomocí čísla, lze ho procházet pouze **postupně**, od začátku do konce
- existují i obousměrné implementace
- výhodou nad polem je možnost jednoduchého přidání prvku doprostřed seznamu
### Množina
- anglicky *set*, někdy *hashset*
- homogenní seznam prvků, které obsahuje pouze unikátní hodnoty
- neordinální => nezachovává pořadí prvků, nelze ho indexovat
- výhodou je velmi rychlá kontrola, zda daný prvek náleží konkrétní množině, či ne
	- zpravidla se jedná o $O(n)$
### Slovník
- anglicky **
- seznam prvků, který ukládá hodnoty pod klíčem
- klíč a hodnoty musí být heterogenní, typ klíč se však může lišit od typu hodnot
- pro indexování nejsou použity přímo klíče, ale jejich hashe => v paměti se tedy většinou jedná pouze o stringy, záleží na implementaci hashovací funkce
	- tímto můžeme jako klíč použít jakýkoliv typ, ze kterého můžeme získat hash
- pokud definujeme např.: a = {"alenka" => 45, "bob" => 12}, můžeme získat hodnotu 12 pomocí a["bob"]
- získání dané hodnoty je opět velmi rychlé, teoreticky se jedná o $O(1)$
	- prakticky záleží na komplexitě funkce, kterou používáme na získání hashe z daného klíče
### Struktura
- datový typ, který je složený z jiných datových typů
- heterogenní "balíček" jiných proměnných
- jeho celková velikost se tedy odvíjí od sumární velikosti všech obsažených hodnot
- v jazyku C ho můžeme definovat například takto:
```C
struct Point {
	int x,
	int y,
}

struct Rectangle {
	Point p1,
	Point p2,
}
```